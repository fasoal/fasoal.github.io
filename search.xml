<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS UI设计规范]]></title>
    <url>%2F2018%2F09%2F14%2FiOS-UI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这篇文章收录了最新iPhone设备尺寸，主要是为了自己方便自己查阅苹果设备尺寸，图标尺寸等，苹果官方有Human Interface Guidelines文档，感兴趣的朋友可以自行查阅。 官方文档地址Human Interface Guidelines 设备尺寸 Device Portrait dimensions Landscape dimensions 12.9” iPad Pro 2048px × 2732px 2732px × 2048px 10.5” iPad Pro 1668px × 2224px 2224px × 1668px 9.7” iPad 1536px × 2048px 2048px × 1536px 7.9” iPad mini 4 1536px × 2048px 2048px × 1536px iPhone XS Max 1242px × 2688px 2688px × 1242px iPhone XS 1125px × 2436px 2436px × 1125px iPhone XR 828px × 1792px 1792px × 828px iPhone X 1125px × 2436px 2436px × 1125px iPhone 8 Plus 1242px × 2208px 2208px × 1242px iPhone 8 750px × 1334px 1334px × 750px iPhone 7 Plus 1242px × 2208px 2208px × 1242px iPhone 7 750px × 1334px 1334px × 750px iPhone 6s Plus 1242px × 2208px 2208px × 1242px iPhone 6s 750px × 1334px 1334px × 750px iPhone SE 640px × 1136px 1136px × 640px 图像大小与分辨率 Device Scale Factor 12.9” iPad Pro @2x 10.5” iPad Pro @2x 9.7” iPad @2x 7.9” iPad mini 4 @2x iPhone XS Max @3x iPhone XS @3x iPhone XR @2x iPhone X @3x iPhone 8 Plus @3x iPhone 8 @2x iPhone 7s Plus @3x iPhone 7s @2x iPhone 7 @2x iPhone 6s Plus @3x iPhone 6s @2x iPhone SE @2x App Icon Sizes Device or context Icon size iPhone 180px × 180px (60pt × 60pt @3x) 120px × 120px (60pt × 60pt @2x) iPad Pro 167px × 167px (83.5pt × 83.5pt @2x) iPad, iPad mini 152px × 152px (76pt × 76pt @2x) App Store 1024px × 1024px (1024pt × 1024pt @1x) Spotlight|Device|Spotlight icon size||:—|:—||iPhone|120px × 120px (40pt × 40pt @3x)|||80px × 80px (40pt × 40pt @2x)||iPad Pro, iPad, iPad mini| 80px × 80px (40pt × 40pt @2x)| Settings|Device| Settings icon size||:—|:—||iPhone| 87px × 87px (29pt × 29pt @3x)|||58px × 58px (29pt × 29pt @2x)||iPad Pro, iPad, iPad mini| 58px × 58px (29pt × 29pt @2x)| Notification|Device|Notification icon size||:—|:—||iPhone| 60px × 60px (20pt × 20pt @3x)|||40px × 40px (20pt × 20pt @2x)||iPad Pro, iPad, iPad mini|40px × 40px (20pt × 20pt @2x)| Launch Screen Device Portrait size Landscape size 12.9” iPad Pro 2048px × 2732px 2732px × 2048px 10.5” iPad Pro 1668px × 2224px 2224px × 1668px 9.7” iPad 1536px × 2048px 2048px × 1536px 7.9” iPad mini 4 1536px × 2048px 2048px × 1536px iPhone XS Max 1242px × 2688px 2688px × 1242px iPhone XS 1125px × 2436px 2436px × 1125px iPhone XR 828px × 1792px 1792px × 828px iPhone X 1125px × 2436px 2436px × 1125px iPhone 8 Plus 1242px × 2208px 2208px × 1242px iPhone 8 750px × 1334px 1334px × 750px iPhone 7 Plus 1242px × 2208px 2208px × 1242px iPhone 7 750px × 1334px 1334px × 750px iPhone 6s Plus 1242px × 2208px 2208px × 1242px iPhone 6s 750px × 1334px 1334px × 750px iPhone SE 640px × 1136px 1136px × 640px Navigation Bar and Toolbar Icon Size（导航栏与工具条） Target sizes（标准大小） Maximum sizes（最大尺寸） 72px × 72px (24pt × 24pt @3x) 84px × 84px (28pt × 28pt @3x) 48px × 48px (24pt × 24pt @2x) 56px × 56px (28pt × 28pt @2x) Tab Bar Icon Size（标签栏图标大小）|Attribute（属性）|Regular tab bars（常规标签栏）|Compact tab bars（紧凑标签栏）||:—|:—|:—||Target width and height (circular glyphs)|75px × 75px (25pt × 25pt @3x)| 54px × 54px (18pt × 18pt @3x)||| 50px × 50px (25pt × 25pt @2x)|36px × 36px (18pt × 18pt @2x)||Target width and height (square glyphs)|69px × 69px (23pt × 23pt @3x)| 51px × 51px (17pt × 17pt @3x)|||46px × 46px (23pt × 23pt @2x)|34px × 34px (17pt × 17pt @2x)||Target width (wide glyphs)|93px (31pt @3x)|69px (23pt @3x)|||62px (31pt @2x)| 46px (23pt @2x)||Target height (tall glyphs)| 84px (28pt @3x)|60px (20pt @3x)|||56px (28pt @2x)|40px (20pt @2x)| 工具推荐这篇文章主要记录了自己平时用的比较多的一些设计尺寸参考，设计细节上的东西还是要去查看官方文档，最后也为推荐一款App Icon自动生成工具吧，只需要一张1024*1024的原图，就可以生成不同设备及尺寸的图标，同时也完全符合苹果设计规范（超👍哦），下面贴出网站地址：图标工厂]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WBLoadingIndicatorView（加载等待动画）]]></title>
    <url>%2F2018%2F09%2F11%2FWBLoadingIndicatorView%EF%BC%88%E5%8A%A0%E8%BD%BD%E7%AD%89%E5%BE%85%E5%8A%A8%E7%94%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、前言 关于加载提示框架，比较成熟的有MBProgressHUD，SVProgressHUD等著名框架，如果没有太多的自定义要求，这些框架提供的API其实已经够用了，基于提供的API，我们也可以自定义一些UI效果。最近项目也不是很忙，于是自己就尝试封装一个加载等待动画组件，封装思想主要参考了MBProgressHUD，在实现过程中，布局采用的是苹果原生Autolayout，没有用Masonry，所以写起来比较的恶心，约束写的老长老长了。其实封装的这个组件功能也不算太多，现在主要实现了五六个加载动画效果，也提供了一些属性设置自定义效果，如果有时间我会优化添加更多动画效果。 二、介绍与使用 一些属性API。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// MARK:Property/* &lt; 动画容器视图 &gt; */@property (nonatomic, strong) WBLoadingBackgroundView *bezelView;/* &lt; 背景视图 &gt; */@property (nonatomic, strong) WBLoadingBackgroundView *backgroundView;/** &lt; Loading text. &gt; */@property (nonatomic, strong) UILabel *label;@property (nonatomic, strong) UIColor *contentColor UI_APPEARANCE_SELECTOR;/* &lt; 加载动画颜色 &gt; */@property (nonatomic, strong) UIColor *indicatorColor UI_APPEARANCE_SELECTOR;/* &lt; bezelView中心点偏移 &gt; */@property (nonatomic, assign) CGPoint offset UI_APPEARANCE_SELECTOR;/* &lt; 边距 默认：20 &gt; */@property (nonatomic, assign) CGFloat margin UI_APPEARANCE_SELECTOR;/* &lt; bezelView最小size &gt; */@property (nonatomic, assign) CGSize minSize UI_APPEARANCE_SELECTOR;/** &lt; 加载动画size 默认：35 &gt; */@property (nonatomic, assign) CGSize indicatorSize UI_APPEARANCE_SELECTOR;/** &lt; 是否方形 &gt; */@property (nonatomic, assign) BOOL square UI_APPEARANCE_SELECTOR;/** &lt; 隐藏时从父视图移除 默认：YES &gt; */@property (nonatomic, assign) BOOL removeFromSuperViewOnHide;/* &lt; 动画类型 &gt; */@property (nonatomic, assign) WBLoadingAnimationType type;// MARK:Class Methods/** 获取视图中的WBLoadingIndicatorView @param view 遍历的父视图 @return WBLoadingIndicatorView */+ (nullable WBLoadingIndicatorView *)wb_indicatorForView:(UIView *)view;/** 创建并显示加载视图 @param view 要显示的view @return MBProgressHUD */+ (instancetype)wb_showIndicatorAddTo:(UIView *)view;// MARK:Instance Class Method- (instancetype)initWithView:(UIView *)view;/** 显示加载视图 */- (void)wb_showLoadingView:(BOOL)animated;/** 隐藏加载视图 @param animated 是否动画 */- (void)wb_hideLoadingView:(BOOL)animated; 部分效果 使用示例1234567WBLoadingIndicatorView *indicatorView = [self createIndicatorViewWithType:WBWBLoadingAnimationBallTrianglePathType indicatorSize:CGSizeMake(50, 50) toView:self.view]; indicatorView.type = WBLoadingAnimationcircleStrokeSpinType; indicatorView.backgroundView.backgroundColor = [UIColor colorWithWhite:0.f alpha:0.3]; indicatorView.contentColor = [UIColor whiteColor]; indicatorView.bezelView.backgroundColor = [UIColor colorWithWhite:0.f alpha:0.7f]; 关于使用，建议还是二次封装吧，每次调用都写这么多代码，还是有点长。关于更多还是查看我的GitHub，下面也贴出GitHub地址。 三、GitHub地址如果觉得可以，请star鼓励一下哦，如果有任何建议或问题，欢迎指出，我也会第一时间修改。WBLoadingIndicatorView]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>GitHub</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods进阶：制作公有库]]></title>
    <url>%2F2018%2F09%2F03%2FCocoaPods%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%88%B6%E4%BD%9C%E5%85%AC%E6%9C%89%E5%BA%93%2F</url>
    <content type="text"><![CDATA[一、 前言在CocoaPods进阶：详解私有库制作这篇博客中，讲解记录了cocoapods使用pod lib create [projectname]命令模板化创建pod私有库，这篇博客主要讲解cocoapods制作共有库的过程。这里，我不在使用模板化方式创建，而是用原来在GitHub上已经提交过的项目（如果你舍不得获得的star，最好采用这种方式啦，😆）。自己也是参照博客资料，本来以为自己有了制作私有库的基础，制作共有库会没那么多的坑，但自己还是折腾了一晚上，好了，不多说了，开始讲解共有库的制作吧！ 二、目录 1、创建spec文件 2、编辑podspec文件 3、本地库验证 4、推送打标签 5、验证podspec文件 6、注册，推送podspec到cocoapods，搜索验证 三、具体步骤1、创建spec文件在xxxx.xcodeproj同级目录下，创建podspec文件 1pod spec create WBHUDManager 创建成功之后如下： 注意： 这里新创建的podspec最好要和LICENSE、README.md在同级目录，自己在这里也折腾了许久，头一次用非模板方式，也踩了不少的坑。这里一定要注意哦。 2、编辑podspec文件** 用终端或者记事本编辑podspec文件，下面是我配置WBHUDManager.podspec，这里我也不做详细的介绍了，在我讲解的私有库制作博客，有对每个属性的详细描述，在网上也能轻易的查阅到相关的资料。 12345678910111213141516171819202122232425Pod::Spec.new do |s| s.name = 'WBHUDManager' s.version = '1.0.0' s.summary = 'iOS 基于SVProgressHUD、MBProgressHUD提示框封装' s.homepage = 'https://github.com/wenmobo/WBHUDManager' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; 'wenmobo' =&gt; 'wenmobo2018@gmail.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/wenmobo/WBHUDManager.git', :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = '8.0' s.requires_arc = true s.source_files = 'WBHUDManager/WBHUDManager.h' s.frameworks = 'UIKit' s.subspec 'SVProgressHUDWBAddtional' do |ss| ss.source_files = 'WBHUDManager/SVProgressHUDWBAddtional/*.&#123;h,m&#125;' ss.dependency 'SVProgressHUD' end s.subspec 'MBProgressHUDWBAddtional' do |ss| ss.source_files = 'WBHUDManager/MBProgressHUDWBAddtional/*.&#123;h,m&#125;' ss.resource = 'WBHUDManager/MBProgressHUDWBAddtional/MBProgressHUD.bundle' ss.dependency 'MBProgressHUD' endend 3、本地库验证 1pod lib lint WBHUDManager.podspec 如果有警告，需要根据提示内容解决警告，忽略警告 1pod lib lint WBHUDManager.podspec --allow-warnings 4、推送打标签 由于这里我之前已经推送到远程了，所以只需要打标签就可了，注意要和WBHUDManager.podspec中version保持一致： 12345git tag -m &apos;release version 1.0.0&apos; 1.0.0git push origin 1.0.0 或者git push --tags 5、验证podspec文件 推送标签之后，需对WBHUDManager.podspec进行验证 1pod spec lint WBHUDManager.podspec 6、注册，推送podspec到cocoapods，验证 验证通过之后，需要使用邮箱注册cocoapods，终端输入： 1234pod trunk register [email] ‘用户名’ --description=&apos;MacBook Pro&apos;examplepod trunk register 123@qq.com &apos;wenbo&apos; --description=&apos;MacBook Pro&apos; 之后会给你发送一条邮箱，进行确认，这里的--description=’MacBook Pro’可以省略 查看个人信息 1pod trunk me 推送podspec到cocoapods 1pod trunk push WBHUDManager.podspec 推送成功之后，终端输出如下 之后我们可以搜索验证 1pod search WBHUDManager 哈哈，已经发布成功啦，是不是很开心啦☺️。 四、问题解决 发布成功之后搜索不到 12345678//删除本地索引rm ~/Library/Caches/CocoaPods/search_index.json//搜索pod search [库名]//更新索引pod repo update 五、打广告 哈哈，最后也为自己打波广告吧，这篇博客使用的例子是自己基于MBProgressHUD、SVProgressHUD封装的一个提示框架，支持超多自定义属性设置，HUD的状态切换，显示完成回调，这也是我发布的第一个公有库，如果有写的不好的地方，请多多包涵。喜欢的朋友记得star鼓励下哟，最后贴出GitHub地址吧： WBHUDManager]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>GitHub</tag>
        <tag>MBProgressHUD</tag>
        <tag>SVProgressHUD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView高度自适应三种方式]]></title>
    <url>%2F2018%2F08%2F27%2FWKWebView%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、前言 ImportantStarting in iOS 8.0 and OS X 10.10, use WKWebView to add web content to your app. Do not use UIWebView or WebView. WKWebVIew是iOS8新出的API，旨在替代原有的UIWebView，相对于UIWebView，WKWebView有着更为强大性能和丰富的API。在项目开发过程中，我也更倾向于用WKWebView,但在使用过程中也遇到许多的问题。 最近接触使用网页视图比较多，自己在tableView和scrollView中嵌套网页视图，在获取网页视图高度遇到过不少的坑，例如高度不准确、底部留白断层，滚动一直获取高度问题。现在项目中使用的网页视图基本都替换成了WKWebView，关于WKWebView使用的一些坑，我强烈推荐一篇博客WKWebView 那些坑，希望使用WKWebView能少走一些弯路，少踩一些坑。好了，话不多说了，我将项目中获取网页视图高度实际经验分享给大家，希望对你有所帮助，下面开始介绍吧！ 二、目录 通过KVO的方式 通过代理的方式 通过注入JS的方式，添加网页加载完成回调获取 通过KVO的方式这种方式获取的高度较为准确，但要注意表格中多次回调高度的问题。 添加监听者 12345#pragma mark ------ &lt; Private Method &gt; ------#pragma mark- (void)addWebViewObserver &#123; [self.wkWebView.scrollView addObserver:self forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionNew context:nil];&#125; 监听高度变化 1234567891011#pragma mark ------ &lt; KVO &gt; ------- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; /** &lt; 法2 &gt; */ /** &lt; loading：防止滚动一直刷新，出现闪屏 &gt; */ if ([keyPath isEqualToString:@&quot;contentSize&quot;]) &#123; CGRect webFrame = self.wkWebView.frame; webFrame.size.height = self.wkWebView.scrollView.contentSize.height; self.wkWebView.frame = webFrame; [self.tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:[NSIndexPath indexPathForRow:3 inSection:0], nil] withRowAnimation:UITableViewRowAnimationNone]; &#125;&#125; 移除观察者 123- (void)removeWebViewObserver &#123; [self.wkWebView.scrollView removeObserver:self forKeyPath:@&quot;contentSize&quot;];&#125; 通过代理的方式这种方法通过WKNavigationDelegate代理方法- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation，网页加载完成通过JS获取网页内容高度，但这种方式不一定就是最真实的高度，这时候可能网页内容还未加载完成，但以实际情况为准。 1234567891011121314151617181920/** &lt; 法2 &gt; */- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; //document.body.offsetHeight //document.body.scrollHeight //document.body.clientHeight [webView evaluateJavaScript:@&quot;document.body.offsetHeight&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; CGFloat documentHeight = [result doubleValue]; CGRect webFrame = webView.frame; webFrame.size.height = documentHeight; webView.frame = webFrame; [self.tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:[NSIndexPath indexPathForRow:3 inSection:0], nil] withRowAnimation:UITableViewRowAnimationNone]; &#125;]; // CGRect webFrame = self.wkWebView.frame;// CGFloat contentHeight = webView.scrollView.contentSize.height;// webFrame.size.height = contentHeight;// webView.frame = webFrame;// [self.tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:[NSIndexPath indexPathForRow:3 inSection:0], nil] withRowAnimation:UITableViewRowAnimationNone];&#125; 通过注入JS的方式，添加网页加载完成回调获取第三种通常是接口返回HTMLString，然后自己在APP客户端成网页html、head、body这些标签，在合适的位置加入以下js代码： 12345&lt;script type=\"text/javascript\"&gt;\ window.onload = function() &#123;\ window.location.href = \"ready://\" + document.body.scrollHeight;\ &#125;\ &lt;/script&gt; 然后借助WKWebView代理方法，就能准确获得网页高度： 123456789101112131415161718- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; if (navigationAction.navigationType == WKNavigationTypeOther) &#123; if ([[[navigationAction.request URL] scheme] isEqualToString:@&quot;ready&quot;]) &#123; float contentHeight = [[[navigationAction.request URL] host] floatValue]; CGRect webFrame = self.wkWebView.frame; webFrame.size.height = contentHeight; webView.frame = webFrame; NSLog(@&quot;onload = %f&quot;,contentHeight); [self.tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:[NSIndexPath indexPathForRow:3 inSection:0], nil] withRowAnimation:UITableViewRowAnimationNone]; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; 第三种方法在我写的demo中是看不到效果的，有兴趣的朋友可以自己拼接网页HTMLString测试效果。我也贴一个我在项目中添加以上代码片段的位置吧： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta name=\"viewport\"content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt;\ &lt;title&gt;&lt;/title&gt; &lt;head&gt;&lt;script type=\"text/javascript\"&gt;\ window.onload = function() &#123;\ window.location.href = \"ready://\" + document.body.scrollHeight;\ &#125;\ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; //接口返回网页内容，拼接在这里 &lt;/body&gt;&lt;/html&gt; 三、问题解决 解决web断层问题：WKWebView刷新机制小探 123456#pragma mark ------ &lt; UIScrollViewDeltegate &gt; ------- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; /** &lt; 解决web白屏问题 &gt; */ /** &lt; 需要调用私有API：_updateVisibleContentRects &gt; */ [self.wkWebView setNeedsLayout];&#125; 四、demo最新demo请戳：WKWebViewAutoHeight 五、参考资料 ios webview自适应实际内容高度5种方法 iOS中webView嵌套tableView中动态高度问题 WKWebView刷新机制小探]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods进阶：详解私有库制作]]></title>
    <url>%2F2018%2F08%2F13%2FCocoaPods%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%AF%A6%E8%A7%A3%E7%A7%81%E6%9C%89%E5%BA%93%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 自己一直想用CocoaPods制作pod库，在自己面试过程中也被面试官问到过组件化开发的概念，然尔自己那时也不是很了解，CocoaPods与组件化也息息相关，利用CocoaPods也便于维护pod组件，于是自己就决定学习用CocoaPods制作pod库，下面就开始讲解私有库的制作过程吧。 目录 安装CocoaPods 创建远程内部私有Spec Repo仓库 模板创建pod库 编辑***.podspec文件 验证本地是否通过 关联本地仓库，并推送到远程仓库，打标签 推送***.podspec到远程 验证远程是否通过 验证私有仓库是否可用，pod集成私有库 安装CocoaPods首先要安装CocoaPods，没有安装可以参考我的博客CocoaPods安装与使用。 创建远程内部私有Spec Repo仓库这步自己采坑不少，一开始自己并不理解，不知到代码仓库和Spec Repo是需要分开存储的。好了，不说自己经历的曲折了，如果你还没有创建远程内部私有Spec Repo仓库, 需要到Github,码云或其他代码托管平台创建远程仓库, 之后将远程仓库克隆到本地，终端执行如下命令： 12//这里可以用https或ssh地址方式克隆pod repo add WBSpecs git@github.com:wenmobo/WBSpecs.git 克隆之后，本地cocoapods目录如下： 模板创建pod库 第二步：在本地任意一个文件夹下创建pod库： 1pod lib create WBAvoidCrash 之后控制台输出 接着会需要回答一些问题： 123456789101112131415# 你想使用哪个平台？1、What platform do you want to use?? [ iOS / macOS ]iOS# 库语言选择？2、What language do you want to use?? [ Swift / ObjC ]ObjC# 你要使用哪个测试框架？3、Which testing frameworks will you use? [ Specta / Kiwi / None ]None# 是否要UI测试？4、Would you like to do view based testing? [ Yes / No ]NO# 类名前缀？5、What is your class prefix?WB 成功之后，目录如下： 工程目录如下： 在工程WBAvoidCrash目录添加我们的代码文件： 添加完成之后如下： 注意：代码文件需要添加到WBAvoidCrash/Classes目录下。 编辑***.podspec文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Pod::Spec.new do |s| #库名称 s.name = &apos;WBAvoidCrash&apos; #指定支持的平台和版本，不写则默认支持所有的平台，如果支持多个平台，则使用下面的deployment_target定义 spec.platform = :ios #版本号 s.version = &apos;1.0.0&apos; #库简短介绍 s.summary = &apos;iOS 防Crash库&apos; #开源库描述 s.description = &lt;&lt;-DESCTODO: iOS防crash库分类. DESC #开源库地址，或者是博客、社交地址等 s.homepage = &apos;https://github.com/wenmobo/WBAvoidCrash&apos; #开源协议 s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; #开源库作者 s.author = &#123; &apos;wenmobo&apos; =&gt; &apos;wenmobo2018@gmail.com&apos; &#125; #开源库GitHub的路径与tag值，GitHub路径后必须有.git,tag实际就是上面的版本 s.source = &#123; :git =&gt; &apos;https://github.com/wenmobo/WBAvoidCrash.git&apos;, :tag =&gt; s.version &#125; #社交网址 s.social_media_url = &apos;http://blogwenbo.com/&apos; #开源库最低支持 s.ios.deployment_target = &apos;8.0&apos; #源库资源文件 s.source_files = &apos;WBAvoidCrash/Classes/**/*&apos; #是否支持arc s.requires_arc = true #依赖系统库 s.frameworks = &apos;Foundation&apos; #开源库依赖库 # s.dependency &quot;Masonry&quot;, &quot;~&gt; 1.0&quot; #添加系统依赖静态库 #s.library = &apos;sqlite3&apos;, &apos;xml2&apos; #添加依赖第三方的framework #s.vendored_frameworks = &apos;XXXX/XXXX/**/*.framework&apos; #静态库.a s.vendored_library = &apos;XXXX/XXX/XXX.a&apos;, &apos;YYY/YYY/Y.a&apos; #添加资源文件 #s.resource = &apos;XXX/XXXX/**/*.bundle&apos; #在 podspec 文件中添加 s.static_framework = true，CocoaPods 就会把这个库配置成static framework。同时支持 Swift 和 Objective-C #s.static_framework = trueend 关于s.source_files写法 123456//表示匹配WBAvoidCrash/Classes下所有文件(主目录和子目录，其中**相当于省略中间层级)&apos;WBAvoidCrash/Classes/**/*&apos;//表示匹配Classes所有以.h和.m结尾的文件&apos;WBAvoidCrash/Classes/*.&#123;h,m&#125;&apos;//表示匹配所有WBAvoidCrash目录下文件，不包含子目录&apos;WBAvoidCrash/*&apos; 更多关于资源目录层级写法可以参考GitHub一些著名框架，AFNetworking.podspec、ZFPlayer.podspec等。 s.dependency关于依赖三库，依赖多个三方库如下： 123s.dependency &apos;Masonry&apos;s.dependency &apos;MJRefresh&apos;s.dependency Masonry &apos;YYModel&apos; 验证本地是否通过 配置好podspec之后，验证本地库是否通过验证，终端输入如下命令： 1pod lib lint 通过验证，终端输出如下： 报如下错误 需在Xcode中配置： 如果pod库存在警告是不能通过验证的，如果要暂时忽略警告通过验证（如码云创建的私有库s.homepage地址不可达警告），可使用如下命令： 1pod lib lint --allow-warnings 你制作的pod库依赖三方库，而三方库包含静态库（如：xxxx.a），在验证的时候，不能验证通过，可使用如下命令： 1234pod lib lint --use-libraries//同时忽略警告pod lib lint --use-libraries --allow-warnings 不管怎样都要解决pod库存在的警告，并通过验证。 关联本地仓库，并推送到远程仓库，打标签 如果你还未创建远程仓库，你需要创建与之对应的远程仓库，我是在GitHub创建的仓库，这里也不再赘述创建方法。创建之后须与本地仓库关联，在终端执行如下命令： 12345678#提交代码到暂存区git add .#提交到本地仓库git commit -m &quot;create WBAvoidCrash Library&quot;#添加到远程仓库git remote add origin git@github.com:wenmobo/WBAvoidCrash.git#推送到远程仓库git push origin master 最近在用码云制作私有库的时候按照上面git命令，在执行git push origin master会报错，需要执行以下命令或者按终端提示的信息操作，第一次才能成功推送到远程仓库： 1git pull --rebase origin master 提交完成之后进行打标签操作： 1234#打标签git tag -a 1.0.0 -m &apos;release version 1.0.0&apos;#推送标签到远程git push origin 1.0.0 友情提示 关于git打标签操作，你可以借助Sourcetree或者终端命令，可以查看我的博客MAC上Git打标签。 推送***.podspec到远程首先将本地WBAvoidCrash.podspec推送到远程私有repo spec仓库和本地repo spec仓库，终端执行如下命令： 12cd [WBAvoidCrash库路径]pod repo push WBSpecs WBAvoidCrash.podspec 验证远程是否通过推送成功之后，终端输入如下命令进行验证： 1pod spec lint WBAvoidCrash.podspec 验证通过终端输出如下： 同样这里如果还存在着警告或者错误，同样不能验证通过，同样可以用以下命令忽略警告通过验证： 123pod spec lint WBAvoidCrash.podspec --allow-warningspod spec lint WBAvoidCrash.podspec --use-librariespod spec lint WBAvoidCrash.podspec --allow-warnings --use-libraries 验证私有仓库是否可用，pod集成私有库验证通过之后，下面进行测试，看是否能通过cocoapods集成到我们的项目，首先用pod命令进行搜索，看能否搜索到： 1pod search WBAvoidCrash 这时可能会报如下错误 不要慌，在终端执行如下命令，然后重新search： 1rm ~/Library/Caches/CocoaPods/search_index.json 耐心等待之后，发现能搜到自己创建的私有库了： 新建一个测试工程测试，用CocoaPods初始化项目，编辑podfile文件： 123456789101112131415161718192021222324#CocoaPods官方spec仓库source 'https://github.com/CocoaPods/Specs.git'#自己私有spec仓库source 'https://github.com/wenmobo/WBSpecs.git'platform :ios, '8.0'target 'Test' do #防Crash库 pod 'WBAvoidCrash' # Pods for Test target 'TestTests' do inherit! :search_paths # Pods for testing end target 'TestUITests' do inherit! :search_paths # Pods for testing endend 编辑好podfile文件之后，终端执行： 123pod install或pod install --no-repo-update 耐心等待一会儿，你会发现私有库已经集成到测试项目中了： 到这里，cocoapods私有库制作已讲解完成。也为自己制作的第一个私有库打波广告吧☺️☺️，WBAvoidCrash一个防Crash库，现在支持9种防崩溃类型，集成方便，使用无需导入相关的头文件，这个库之前没这么完善，后来参考借鉴了一些大神开源的库。下面👇贴出私有库地址吧： WBAvoidCrash 相关命令cocoapods 更新repo 1234//更新所有repopod repo updatepod repo [spec库名] 验证pod库 1234567//验证本地pod库pod lib lint//本地验证忽略警告pod lib lint --allow-warnings//验证远程pod spec lint [name].podspec 搜索pod库 1pod search [库名] 结语 终于完成这篇博客了，从自己比较熟悉GitHub之后，也想过自己能够开源一款三方库，然而自己水平有限，现在还没有拿的出来好的封装库或一些好的封装思想。但自己还是要学会制作pod库，在写博客之前，自己在谷歌浏览器查了许多的资料，资料也是比较的凌乱，自己在制作过程中也踩了许多的坑，最后自己也成功制作了一个私有库WBAvoidCrash，过程虽然有些坎坷，但自己还是很有成就感。自己也是第一次制作，如果有描述不对的地方，希望大家能够批评指正，我也会第一时间修改，同时也希望这篇博客对需要的朋友一些帮助，接下来我也会写一篇记录公开库制作过程的博客。 参考文章1、 CocoaPods创建公有和私有Pod库方法总结2、出现Unable to find a pod with name, author, summary, or description matching解决方法3、如何发布自己的开源框架到CocoaPods4、使用CocoaPods管理iOS库—制作pod篇5、如何创建私有 CocoaPods 仓库6、Making a CocoaPod7、Create and Distribute Private Libraries with Cocoapods]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods安装与使用]]></title>
    <url>%2F2018%2F08%2F01%2FCocoaPods%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[更新日志2018-08-01：整理文章目录结构，添加忽略CocoaPods警告方法，解决出现OTHER_LDFLAGS方法。 介绍内容目录 一、安装RVM 二、配置RubyGems 三 、CocoaPods安装 四 、CocoaPods使用 五、问题解决一、安装RVM 安装RVM命令如下： 1curl -L get.rvm.io | bash -s stable 查看rvm版本 1rvm -v 更新RVM 1rvm get stable 查看可下载的ruby版本 1rvm list known 输出结果为：123456789101112# MRI Rubies[ruby-]1.8.6[-p420][ruby-]1.8.7[-head] # security released on head[ruby-]1.9.1[-p431][ruby-]1.9.2[-p330][ruby-]1.9.3[-p551][ruby-]2.0.0[-p648][ruby-]2.1[.10][ruby-]2.2[.7][ruby-]2.3[.4][ruby-]2.4[.1]ruby-head 选择版本安装12//安装2.4.1rvm install 2.4.1 安装如果遇到如下错误：安装Command Line Tools即可1xcode-select --install 查看已安装的版本1rvm list 输出结果如下：12345rvm rubies=* ruby-2.4.1 [ x86_64 ]# =&gt; - current# =* - current &amp;&amp; default# * - default 查看当前使用的版本 1rvm current 设置默认版本 1rvm use 2.4.1 --default 删除安装过的版本 1rvm remove 2.2.2 如果提示权限不足，同理加上sudo1sudo rvm remove 2.2.2 二、升级RubyGems 在终端输入：1gem update --system 若果是最新，则输出：1Latest version currently installed. Aborting. 若果没有权限报错，在命令前加上sudo 1sudo gem update --system 更换源（最新使用的是：https://gems.ruby-china.org/） 123gem sources --remove https://rubygems.org/gem sources -a https://gems.ruby-china.org/ 查看ruby镜像 1gem source -l 输出结果：1https://gems.ruby-china.org/ 三、CocoaPods安装 终端输入 123sudo gem install cocoapods或sudo gem install -n /usr/local/bin cocoapods 安装了多个xcode进行选择 1sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer 安装本地库 1pod setup 执行上面的命令过后，会出现卡主不动，这个是时候是在下载，通常会等很久。这是后可以通过cmmand+n新创一个终端窗口，然后cd ~/.cocoapods/到该文件下，执行du -sh *查看大小：11015M repos 查看版本 1pod --version 升级CocoaPods 123sudo gem install -n /usr/local/bin cocoapods或sudo gem install cocoapods 四、CocoaPods使用工程导入三方库 创建一个工程test，终端切换到工程路径： 1cd 工程路径 终端输入： 1pod init 这时工程就会生成一个podfile 编辑podfile：1vim podfile 进入之后按i进入编辑模式，添加三方开源库如：pod &#39;AFNetworking&#39;(也可指定版本pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;)，然后输入:wq回车保存。1234567891011121314# Uncomment the next line to define a global platform for your project# platform :ios, &apos;9.0&apos;pod &apos;AFNetworking&apos;target &apos;test&apos; do # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for testend~ ~ ~ :wq 执行安装123pod install或pod install --no-repo-update 好了，到此CocoaPods的安装与使用都介绍完毕。 更新三方库 更新所有三方库 12//更新所有可更新的三方库pod update 间接更新三方库 12345678cd ~/.cocoapodslscd reposlscd masterlsls -agit pull 更新指定库 1pod update Masonry 省时更新方法 1pod update --verbose --no-repo-update 移除导入过的三方库 第一步：编辑podfile，将需要删除的三方库移除掉pod ‘AFNetworking’, ‘~&gt;3.1.0’ 第二步：执行pod install，重新编译，如果没有报错则移除成功1pod install 移除工程中CocoaPods 删除工程文件夹下的Podfile、Podfile.lock和Pods文件夹 删除xcworkspace文件 打开xcodeproj文件，删除项目中的libpods.a和Pods.xcconfig引用 打开Build Phases选项，删除Check Pods Manifest.lock和Copy Pods Resources主要就是上面四个步骤。五、问题解决1、执行gem update --system报证书错误，在网上找了很久也没有找到解决方法，后来还是找到了,方法是忽略证书验证。步骤：前往~/.gemrc，打开文件，并添加:ssl_verify_mode: 012345678---:backtrace: false:bulk_threshold: 1000:sources:- https://gems.ruby-china.org/:update_sources: true:verbose: true:ssl_verify_mode: 0 cmmand+s保存，然后在执行sudo gem update --system，更新成功。 2、Unable to require openssl, install OpenSSL and rebuild ruby12345//如果没有安装openssl，则用honebrew安装brew install openssl//重装rvm并关联opensslrvm reinstall 2.4.0 --with-openssl-dir=`brew --prefix openssl` 如果安装了2.4.0版本则重新安装，没有安装则安装，安装成功之后，就能sudo gem update --system正常更新了。 3、CocoaPods 出现 OTHER_LDFLAGS 错误，如下图所示 解决方法1：Target–&gt;Build Settings–&gt;Other Linker Flags中添加$(inherited)，之后执行pod install或pod update警告就会消失。 解决方法2:project.xcodeproj右键显示包内容，用文本编辑器打开 project.pbxproj，command + F 搜索 OTHER_LDFLAGS ，删除搜索到的设置，command + S 保存，然后重新执行 pod install 或者 pod update 。 4、Cocoapods第三方库编译提示warning的解决方法 忽略所有警告 1inhibit_all_warnings! 之后执行pod install 或 pod update 即可。 忽略单个库警告 1pod &apos;Masonry&apos;, :inhibit_warnings =&gt; true 之后执行pod install 或 pod update 即可。 总结 CocoaPods安装与使用就介绍到这里了，如果在以后CocoaPods安装使用工程中遇到问题，如果找到了解决方案，我也会贴出来。 参考文章 iOS 删除已经配置的类库和移除CocoaPods 使用CocoaPods（二）删除已经配置的类库和移除CocoaPods 【iOS 开发】解决使用 CocoaPods 执行 pod install 时出现 - Use the $（inherited） flag … 警告 Cocoapods第三方库编译提示warning的解决方法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS状态栏配置]]></title>
    <url>%2F2018%2F07%2F26%2FiOS%E7%8A%B6%E6%80%81%E6%A0%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、全局配置状态栏 在info.plist中添加key：View controller-based status bar appearance，并设置value为NO。 在需要设置样式的地方调用： 123//UIStatusBarStyleLightContent：Light content, for use on dark backgrounds//UIStatusBarStyleDefault：Dark content, for use on light backgrounds[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent; 二、配置单个控制器状态栏 在info.plist中添加key：View controller-based status bar appearance，并设置value为YES。 如果有控制器没有导航控制器，直接重写preferredStatusBarStyle 方法返回你想要的状态栏样式即可： 123- (UIStatusBarStyle)preferredStatusBarStyle &#123; return UIStatusBarStyleLightContent;&#125; 通常都有导航控制器，如果控制器中直接重写preferredStatusBarStyle是没有效果的，这时需要在基类导航控制器中重写childViewControllerForStatusBarStyle 、preferredStatusBarStyle 任意一个方法就能实现配置单个控制器的状态栏样式： 12345678- (UIViewController *)childViewControllerForStatusBarStyle &#123; return self.topViewController;&#125;或者重写- (UIStatusBarStyle)preferredStatusBarStyle &#123; return [self.topViewController preferredStatusBarStyle];&#125; 注意：两个方法都重写，只会调用childViewControllerForStatusBarStyle，所以需要自己根据清空去选择调用那个方法。 三、通过分类实现 在项目中方便使用，我写了一个UINavigationController（WBStatusBarStyle） 分类，主要代码如下： 12345678910111213141516171819202122232425@implementation UINavigationController (WBStatusBarStyle)+ (void)wb_setDefaultStatusBarStyle:(UIStatusBarStyle)statusBarStyle &#123; objc_setAssociatedObject(self, &amp;kWBDefaultStatusBarStyleKey, @(statusBarStyle), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;+ (UIStatusBarStyle)wb_DefaultStatusBarStyle &#123; id style = objc_getAssociatedObject(self, &amp;kWBDefaultStatusBarStyleKey); return style ? [style integerValue] : UIStatusBarStyleDefault;&#125;/** &lt; Override to return a child view controller or nil. If non-nil, that view controller&apos;s status bar appearance attributes will be used. If nil, self is used. Whenever the return values from these methods change, -setNeedsUpdatedStatusBarAttributes should be called. &gt; *///- (UIViewController *)childViewControllerForStatusBarStyle &#123;// return self.topViewController;//&#125;////- (UIViewController *)childViewControllerForStatusBarHidden &#123;// return self.topViewController;//&#125;- (UIStatusBarStyle)preferredStatusBarStyle &#123; return [self.topViewController wb_statusBarStyle];&#125;@end UIViewController (WBStatusBarStyle) 1234567891011121314@implementation UIViewController (WBStatusBarStyle)- (void)setWb_statusBarStyle:(UIStatusBarStyle)wb_statusBarStyle &#123; objc_setAssociatedObject(self, &amp;kWBStatusBarStyleKey, @(wb_statusBarStyle), OBJC_ASSOCIATION_RETAIN_NONATOMIC); /** &lt; Whenever the return values from these methods change, -setNeedsUpdatedStatusBarAttributes should be called. &gt; */ [self setNeedsStatusBarAppearanceUpdate];&#125;- (UIStatusBarStyle)wb_statusBarStyle &#123; id style = objc_getAssociatedObject(self, &amp;kWBStatusBarStyleKey); return style ? [style integerValue] : [UINavigationController wb_DefaultStatusBarStyle];&#125;@end 四、GitHub Demo WBManageStatusBarStyleDemo WBCategories]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Runtime</tag>
        <tag>Category</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo七牛插件安装与使用]]></title>
    <url>%2F2018%2F07%2F08%2FHexo%E4%B8%83%E7%89%9B%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[相关网址 hexo-qiniu-sync 七牛云注册七牛个人账号 首先需要到七牛云官网注册个人账号。 进入控制台创建存储空间，如下图所示： 将融合 CDN默认域名添加到万网中，配置格式如下图所示：安装七牛云插件 安装七牛云插件1npm install hexo-qiniu-sync --save 配置相关信息 配置站点文件_config.yml，配置入内容（注意：添加到配置文件时，把//去掉） 12345678910111213141516171819202122232425262728#plugins:# - hexo-qiniu-syncqiniu: offline: false sync: true bucket: blogwenbo //这里将其注释掉，不注释，执行hexo g报错 # secret_file: sec/qn.json or C: access_key: your access_key secret_key: your secret_key // 上传的资源子目录前缀.如设置，需与urlPrefix同步 dirPrefix: static //外链前缀 urlPrefix: http://p2zukkwm9.bkt.clouddn.com/static //使用默认配置即可 up_host: http://upload.qiniu.com //本地目录 local_dir: static // 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传) update_exist: true image: folder: images extend: js: folder: js css: folder: css 生成七牛配置路径，执行下面命令任意一个 12345678910111213hexo s或hexo g//终端输出INFO -----------------------------------------------------------INFO qiniu state: onlineINFO qiniu sync: trueINFO qiniu local dir: staticINFO qiniu url: http://blogwenbo.com/staticINFO -----------------------------------------------------------INFO Start processingINFO Now start qiniu sync.INFO Need upload file num: 0 就会在static目录下生成images、css、js三个文件夹。这时我们把测试图片七牛云.png放在images文件夹下，然后按照如下标签语法书写： 1&#123;% qnimg 七牛云.png title:七牛云 alt:七牛云 &apos;class:&apos; extend:?imageView2/2/w/450 %&#125; 同步静态资源到七牛云空间，主要有两种方式，一种是使用hexo命令，还有一种是使用七牛插件命令，可以参考GitHub文档：hexo-qiniu-sync 123456789101112//1、启用本地服务器.即使用 hexo server 命令（简写为 hexo s）//当以本地服务器模式启动后，会自动监测 local_dir 目录下的文件变化， 会自动将新文件进行上传。如果文件进行了修改，但设置中没有启用 update_exist 配置，则不会更新到七牛空间。hexo shexo server//2、使用命令行命令(sync | s | sync2 | s2)//命令行命令会扫描 local_dir 目录下的文件，同步至七牛空间。hexo qiniu synchexo qiniu shexo qiniu sync2hexo qiniu s2 图片处理可参考官方文档图片基本处理 问题解决 没有注释secret_file: sec/qn.json or C:报错，如下图所示： 1# secret_file: sec/qn.json or C: hexo-qiniu-sync安装好后，hexo s命令不见了，hexo d也提示问题 #41 123//将其注释就好了#plugins:# - hexo-qiniu-sync 结语自己也参考了一些文章，但讲解的都不是很详细完整，有些博客只讲解了重要的一些步骤，不管怎样，最后自己还是捣腾出来了，还是挺折腾人的，我也是第一次用七牛云存储图片，有些地方可能讲解的不是很完整，也请谅解。希望本篇博客能给你一些帮助，也欢迎大家一起交流学习。成功案例：Hexo七牛插件安装与使用。 参考文章Hexo 七牛同步插件的使用]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>QiNiu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WBHUDManager]]></title>
    <url>%2F2018%2F07%2F08%2FWBHUDManager%2F</url>
    <content type="text"><![CDATA[更新日志2018-08-01：更新API，支持配置更多自定义设置，录制GIF。 2018-09-09：支持pod安装 前言 在我们平时做项目的时候，为了提高交互体验，难免会用到一些提示语。除了UI上有特殊的要求需要自定义提示UI，一般会选择GitHub上一些知名的提示框架库，如： MBProgressHUD SVProgressHUD JGProgressHUD Toast 之前做项目都是用的SVProgressHUD，这个三方提示库使用非常接单，基于这个库，也很好做自定义提示封装。后来做项目改成了MBProgressHUD，相对于SVProgressHUD，MBProgressHUD使用相对来说要麻烦一点，因此，我对MBProgressHUD一些常用提示进行了封装，最开始封装的工具类存在着一些缺点，比如说在网络请求的时候，如果网络不好，拿不到回调，MBProgressHUD就会一直显示，用户无法交互，因此对这个工具类进行了改进。 MBProgressHUD(v1.1.0)我主要写了一个分类，有菊花、文字、文字+图片提示，并提供了显示完成对调，方便显示完成后进行相应的操作或界面跳转，提供的调用方法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317// MARK:Loading/** 只显示菊花，不会自动消失 (白字+黑底) @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showActivity;/** 只显示菊花，不会自动消失 (白字+黑底+自定义视图) @param view 要显示的视图 @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showActivity:(UIView *)view;/** 菊花+文字 (白字+黑底) @param message 加载文字 @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showActivityMessage:(NSString *)message;/** 菊花+文字 (白字+黑底) @param message 加载文字 @param view 要显示的视图 @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showActivityMessage:(NSString *)message toView:(UIView *)view;/** 菊花+文字 （自定义文字+内容颜色+蒙版颜色+容器颜色） @param message 加载文字 @param view 要显示的视图 @param contentColor 内容颜色 @param maskColor 蒙版颜色 @param bezelColor 容器颜色 @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showActivityMessage:(NSString *)message toView:(UIView *)view contentColor:(UIColor *)contentColor maskColor:(UIColor *)maskColor bezelColor:(UIColor *)bezelColor;/** 菊花+文字 （自定义文字+文字颜色+蒙版颜色+容器颜色） @param message 加载文字 @param view 要显示的视图 @param titleColor 文字颜色 @param maskColor 蒙版颜色 @param bezelColor 容器颜色 @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showActivityMessage:(NSString *)message toView:(UIView *)view titleColor:(UIColor *)titleColor maskColor:(UIColor *)maskColor bezelColor:(UIColor *)bezelColor;// MARK:Text/** 提示文字 （自定义文+位置中间 + 显示在window） @param message 文字 */+ (void)wb_showMessage:(NSString *)message;/** 提示文字 (标题 + 详情文字) @param message 文字 @param detailMessage 详情文字 */+ (void)wb_showMessage:(NSString *)message detailMessage:(NSString *)detailMessage;/** 提示文字 (标题 + 详情文字 + 自定义位置 + 视图) @param message 文字 @param detailMessage 详情文字 @param position 位置 */+ (void)wb_showMessage:(NSString *)message detailMessage:(NSString *)detailMessage toView:(UIView *)view position:(WBHUDPositionStyle)position;/** 提示文字（自定义文+位置中间+显示在window+完成回调） @param message 文字 @param completion 完成回调 */+ (void)wb_showMessage:(NSString *)message completion:(MBProgressHUDCompletionBlock)completion;/** 提示文字（自定文字+位置中间+自定义显示视图+完成回调） @param message 文字 @param view 要显示的视图 @param completion 完成回调 */+ (void)wb_showMessage:(NSString *)message toView:(UIView *)view completion:(MBProgressHUDCompletionBlock)completion;/** 提示文字 (自定义文字+自定义位置+自定义显示视图) @param message 文字 @param view 要显示的视图 @param position 位置 @param completion 完成回调 */+ (void)wb_showMessage:(NSString *)message toView:(UIView *)view position:(WBHUDPositionStyle)position completion:(MBProgressHUDCompletionBlock)completion;/** 提示文字 (自定义文字+详情文字+自定义位置+内容样式) @param message 文字 @param detailTitle 详情文字 @param view 要显示的视图 @param position 显示位置 @param contentStyle 内容样式 @param completion 完成回调 */+ (void)wb_showMessage:(NSString *)message detailTitle:(NSString *)detailTitle toView:(UIView *)view position:(WBHUDPositionStyle)position contentStyle:(WBHUDContentStyle)contentStyle completion:(MBProgressHUDCompletionBlock)completion;// MARK:Image/** 自定义成功提示 (显示在window) @param success 提示文字 */+ (void)wb_showSuccess:(NSString *)success;/** 自定义成功提示 (显示在window + 完成回调) @param success 提示文字 @param completion 完成回调 */+ (void)wb_showSuccess:(NSString *)success completion:(MBProgressHUDCompletionBlock)completion;/** 自定义成功提示 (显示在window + 完成回调 + 自定义显示视图) @param success 提示文字 @param view 显示视图 @param completion 完成回调 */+ (void)wb_showSuccess:(NSString *)success toView:(UIView *)view completion:(MBProgressHUDCompletionBlock)completion;/** 错误提示 (显示在window) @param error 提示文字 */+ (void)wb_showError:(NSString *)error;/** 错误提示 (显示在window + 完成回调) @param error 错误提示 @param completion 完成回调 */+ (void)wb_showError:(NSString *)error completion:(MBProgressHUDCompletionBlock)completion;/** 错误提示 (显示在window + 完成回调 + 自定义显示视图) @param error 错误提示 @param view 示视图 @param completion 完成回调 */+ (void)wb_showError:(NSString *)error toView:(UIView *)view completion:(MBProgressHUDCompletionBlock)completion;/** 信息提示 (window) @param info 提示文字 */+ (void)wb_showInfo:(NSString *)info;/** 信息提示 (window + 完成回调) @param info 提示文字 @param completion 完成回调 */+ (void)wb_showInfo:(NSString *)info completion:(MBProgressHUDCompletionBlock)completion;/** 信息提示 (window + 完成回调 + 自定义显示视图) @param info 提示文字 @param view 自定义显示视图 @param completion 完成回调 */+ (void)wb_showInfo:(NSString *)info toView:(UIView *)view completion:(MBProgressHUDCompletionBlock)completion;/** 警告提示 (window) @param warning 提示文字 */+ (void)wb_showWarning:(NSString *)warning;/** 警告提示 (window + 完成回调) @param warning 警告 @param completion 完成回调 */+ (void)wb_showWarning:(NSString *)warning completion:(MBProgressHUDCompletionBlock)completion;/** 警告提示 (window + 完成回调 + 自定义视图) @param warning 警告 @param view 自定义视图 @param completion 完成回调 */+ (void)wb_showWarning:(NSString *)warning toView:(UIView *)view completion:(MBProgressHUDCompletionBlock)completion;/** 自定义图片 + 文字提示 @param text 文字 @param icon 图片名 @param view 要显示的视图 @param completion 完成回调 */+ (void)wb_show:(NSString *)text icon:(NSString *)icon view:(UIView *)view completion:(MBProgressHUDCompletionBlock)completion;// MARK:Switch Model/** Model切换 @param view 要显示的视图 @param title 要显示的文字 @param configBlock 配置hud @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showModelSwitch:(UIView *)view title:(NSString *)title configBlock:(WBHUDConfigBlock)configBlock;// MARK:Progress/** 文字 + 进度条 @param view 要显示的视图 @param progressStyle 进度样式 @param title 提示文字 @param configBlock 进度配置block @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showDownloadToView:(UIView *)view progressStyle:(WBHUDProgressStyle)progressStyle title:(NSString *)title configBlock:(WBHUDConfigBlock)configBlock;/** 文字 + 进度条 + 取消按钮 @param view 要显示的视图 @param progressStyle 进度样式 @param title 提示文字 @param cancelTitle 取消按钮标题 @param configBlock 进度配置block @param cancelBlock 取消按钮点击回调 @return MBProgressHUD实例对象 */+ (MBProgressHUD *)wb_showDownloadToView:(UIView *)view progressStyle:(WBHUDProgressStyle)progressStyle title:(NSString *)title cancelTitle:(NSString *)cancelTitle configBlock:(WBHUDConfigBlock)configBlock cancelBlock:(WBHUDCancelBlock)cancelBlock;// MARK:Hide+ (void)wb_hideHUD;+ (void)wb_hideHUDForView:(UIView *)view; 举一个.m显示菊花方法的例子吧，MBProgressHUD最新版本对比老版本API还是有些变化的：1234567891011121314151617181920212223242526272829/** &lt; 创建HUD &gt; */+ (MBProgressHUD *)wb_createHUD:(UIView *)view &#123; if (view == nil) view = (UIView *)[UIApplication sharedApplication].delegate.window; return [MBProgressHUD showHUDAddedTo:view animated:YES];&#125;/** &lt; 设置HUD &gt; */+ (MBProgressHUD *)wb_configHUDWithView:(UIView *)view title:(NSString *)title autoDismiss:(BOOL)autoDismiss completion:(MBProgressHUDCompletionBlock)completion &#123; MBProgressHUD *hud = [self wb_createHUD:view]; /** &lt; 自动换行 &gt; */ hud.label.numberOfLines = 0; /** &lt; 提示文字 &gt; */ hud.title(title); /** &lt; 隐藏移除 &gt; */ hud.removeFromSuperViewOnHide = YES; /** &lt;默认内容样式：黑底白字 &gt; */ hud.hudContentStyle(WBHUDContentBlackStyle); /** &lt; 自动隐藏 &gt; */ if (autoDismiss) &#123; [hud hideAnimated:YES afterDelay:KHideAfterDelayTime]; &#125; hud.completionBlock = completion; return hud;&#125; 感兴趣的朋友，可以下载Demo查看具体方法实现，请戳：WBHUDManager 结语 选择哪一款提示框架，都要看自己喜好了，因为我代码水平有限，有些地方可能考虑的不够完善，只能说是抛砖引玉吧，大神们可能有更好的封装。要想基于这些框架自定义出自己需要风格的UI，还是要对框架提供的方法属性有一定的了解。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GitHub</tag>
        <tag>MBProgressHUD</tag>
        <tag>Objective-C</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X系统常用工具]]></title>
    <url>%2F2018%2F07%2F08%2FMac-OS-X%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[分类目录 版本控制 Cornerstone Sourcetree Tower GitHubDesktop 办公 office2016 效率 Alfred 实用 Mounty CleanMyMac HideSwitch LICEcap iOS开发必备 Dash 真机调试包 数据库管理 Navicat 设计工具 Sketch MarkDown 工具 Typora iPic Cmd Markdown Sublime Text 网络工具 shadowsocks Charles 终端工具 iTerm 2 版本控制Cornerstone Cornerstone is an elegant SVN client designed specifically for the Mac. It is built on Subversion, a popular version control system well-known for its performance, flexibility, and scalability. Cornerstone excels in tracking &amp; displaying changes to data; its comparison tools enable users to view differences in multi-language formats. Better yet, Planio is now integrated into the Cornerstone environment — so you can now easily sync a local folder with your Planio repositories using your Mac! MAC上一款优雅的SVN客服端，进入公司后，使用的第一款项目版本控制工具就是它了。它是建立在Subversion之上的，因其简洁、灵活、可扩展性而闻名。 官方网站：planio Sourcetree Simplicity and power in a beautiful Git GUI. 一款免费非常值得推荐的Git GUI图形客户端。自己托管在GitHub上的demo就是用的这款软件，使用很方便，免去了git繁琐命令，极大提高了工作效率。 官方网站：Sourcetree相关博客：Sourcetree安装与使用 Tower Version control with Git - made easy.In a beautiful, efficient, and powerful app. MAC&amp;&amp;Windows平台上最好用的Git GUI客户端。不像Sourcetree，这个款软件是付费的，RMB大概500元左右，不过也有破解版的，我也没有使用过，感觉功能和Sourcetree差不多吧。 官方网址：git-tower GitHubDesktop Extend your GitHub workflow beyond your browser with GitHub Desktop, completely redesigned with Electron. Get a unified cross-platform experience that’s completely open source and ready to customize. 在我搜索MAC上好用的Git GUI客户端时下载用过，功能不是很多，基本的Git操都有，可以自己去了解下吧。 官方网址：GitHubDesktop 网络工具shadowsocks A secure socks5 proxy, designed to protect your Internet traffic. 一个安全的socks5代理，旨在保护你的网络流量。ShadowsocksX-NG有些文件是用swift写的，也是最近才接触，配置VPN时用到。 官网网址：shadowsocks Charles Charles is an HTTP proxy / HTTP monitor / Reverse Proxy that enables a developer to view all of the HTTP and SSL / HTTPS traffic between their machine and the Internet. This includes requests, responses and the HTTP headers (which contain the cookies and caching information). Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 官方网址：Charles iOS开发必备Dash Dash is an API Documentation Browser and Code Snippet Manager. Dash stores snippets of code and instantly searches offline documentation sets for 200+ APIs, 100+ cheat sheets and more. You can even generate your own docsets or request docsets to be included. 开发人员不可缺少的杰作。作为一名开发开者，我们可以通过这款软件阅读官方文档，存储代码片段，离线搜索API文档集，开发必备软件。 官方网站：Dash 实用工具LICEcap simple animated screen captures 一款简单好用的屏幕GIF录制软件。比如做demo的时候，录制demo效果。 官网网址：LICEcap相关博客：licecap For Mac安装与使用 Mounty A tiny tool to re-mount write-protected NTFS volumes under Mac OS X 10.9+ in read-write mode. 一款MAC上mini的NTFS读写软件，相比付费的NTFS读写软件，这款软件值得推荐哦。 官网：Mounty通过Homebrew安装：1brew cask install mounty HideSwitch 一款实用小工具，显示和隐藏系统隐藏文件，和Show Or Hide这个款软件类似。 CleanMyMac MAC系统清理软件，MAC上非常值得推荐的一款软件，不过是需要付费的，不过也有破解版的哦。 官方中文网站：mycleanmymac 效率Alfred Alfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys, keywords, text expansion and more. Search your Mac and the web, and be more productive with custom actions to control your Mac. 它是MAC OS X一款可以极大提高操作效率的软件，被人称之为一款神器。我们可以通过快捷键唤出Alfred，然后通过关键词搜索，总之，它是一款强大的软件。我也是最近才安装，了解的也不是很多，有兴趣的朋友可以下载使用吧。 官方网站：Alfred 办公office2016 MAC平台下的办公软件。 终端工具iTerm 2 iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with macOS 10.10 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted. MAC上最好用的终端工具。 官方网站：iTerm 2相关博客：MAC上iTerm 2安装与使用 数据库管理Navicat Powerful . Intuitive . Easy-to-use The ultimate solution for MongoDB management and development Navicat是一套快速、可靠并价格相当便宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。 官方网址：Navicat MarkDown 工具Typora Typora will give you a seamless experience as both a reader and a writer. It removes the preview window, mode switcher, syntax symbols of markdown source code, and all other unnecessary distractions. Replace them with a real live preview feature to help you concentrate the content itself. 所见即所得，一款免费MarkDown编辑工具，自己也有使用一段时间，开始觉得挺好用的，后来发现有些操作有些卡顿不流畅，后来就放弃了，不过还是值得推荐。 官方网址：Typora iPic 一款图床神器，还在为MarkDown图传选择而烦恼吗，iPic将是你不错的选择，可直接在App Store下载。 介绍博客 Cmd Markdown 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 作业部落 Cmd Markdown这款编辑器，放弃Typora之后，最近在使用这款编辑器，感觉用起来比较稳定流畅，支持在线存储，如果你最求稳定，它将是一款不错的选择哦。 官方网址：Cmd Markdown Sublime Text A sophisticated text editor for code, markup and prose. Sublime Text是一套跨平台的文本编辑器，支持基于Python的插件。Sublime Text是专有软件，可透过包（Package）扩展。大多数的包使用自由软件授权发布，并由社群建置维护。在自己最开始接触Markdown的时候安装使用过，但是觉得写作的时候不够直观，就放弃了，最近发现这款工具真的很强大，对于代码块的编辑，有联想功能，非常值得推荐。 官方网址：Sublime_Text]]></content>
      <categories>
        <category>MAC</category>
      </categories>
      <tags>
        <tag>MAC</tag>
        <tag>DMG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WBCategoryKit]]></title>
    <url>%2F2018%2F07%2F08%2FWBCategoryKit%2F</url>
    <content type="text"><![CDATA[中文说明 Some useful Objective-C ategories and Macro,that contain UIKit.framework、Foundation.framework、AVFoundation.framework、QuartzCore. framework、CoreTelephony.framework、WebKit.framework、MobileCoreServices.framework、Photos.framework、AssetsLibrary.framework、Accelerate.framework、ImageIO.framework、CoreText.framework、CoreGraphics.framework and so on,i will continue to tidy up updates. iOS 系统常用框架分类封装，开发常用宏定义，支持cocoapod集成，支持只集成子模块。持续更新中… Requirements iOS 8+ Xcode 8+ InstallationCocoapods安装 安装所有分类文件 1pod 'WBCategoryKit' 集成子组件 1pod 'WBCategoryKit/UIKit' 或者1pod 'WBCategoryKit/UIKit/WKWebView' 手动集成将需要的分类文件拖入工程即可。 UsageFoundation NSObject 1234//swizzle 类方法+ (void)swizzleClassMethodWithOriginSel:(SEL)oriSel swizzledSel:(SEL)swiSel selfClass:(Class)selfClass; 1234//swizzle 实例方法 + (void)swizzleInstanceMethodWithOriginSel:(SEL)oriSel swizzledSel:(SEL)swiSel selfClass:(Class)selfClass; NSDate 12//NSDateFormatter缓存 - (NSDateFormatter *)wb_dateFormatterWithFormat:(NSString *)format; //朋友圈时间格式1+ (NSString *)compareCurrentTimeWithTimeString:(NSString *)timeString; Macro//设置平方字体PingFangSC12#define kWB_PFR kWB_SYSTEM_VERSION_9_OR_LATER ? @&quot;PingFangSC-Regular&quot; : @&quot;PingFang SC&quot;#define kWB_PFR_FONT(s) [UIFont fontWithName:kWB_PFR size:s] //主线程安全执行123#ifndef dispatch_main_async_safe#define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)#endif //同步锁12#define kWB_LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);#define kWB_UNLOCK(lock) dispatch_semaphore_signal(lock); UIKit WKWebView 123//获取某个标签的结点个数- (void)wb_nodeCountOfTag:(NSString *)tagcompletedHandler:(void (^) (int tagCount))completedHandler; 12//获取网页中的图片 - (void)wb_getImages:(void (^) (NSArray *images))completedHandler; 12//获取网页内容高度- (void)wb_getScrollHeight:(void (^) (CGFloat scrollHeight))completedHandler; 12//为所有图片添加点击事件- (void)wb_addClickEventOnImg; 12//根据id隐藏网页元素- (void)wb_hiddenElementById:(NSString *)idString; UIFont 12345//runtime字体适配+ (UIFont *)_wb_systemFontOfSize:(CGFloat)fontSize;+ (UIFont *)_wb_boldSystemFontOfSize:(CGFloat)fontSize;+ (UIFont *)_wb_fontWithName:(NSString *)fontName size:(CGFloat)fontSize; 更多分类使用方法，请查看WBCategoryKit。 补充本库主要是记录自己积累学习的一个过程，最初在github创建这个工程的时候，我就在自己的博客中写道将来有一天将本库制作成pod公有库，如今完成了本库的制作，虽然在制作过程中遇到了很多的问题，但还是很有成就感。如过在使用过程中，有任何建议或者问题，可以通过以下方式联系我，十分感谢。 author：wenbo QQ：1050794513 email：1050794513@qq.com 喜欢就❤️下鼓励下吧。 更新 2018-09-05 （1.0.2）： 修改podspec文件，支持三级目录。 https://www.jianshu.com/p/e917e7d95f69)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>GitHub</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC上iTerm 2安装与使用]]></title>
    <url>%2F2018%2F07%2F08%2FMAC%E4%B8%8AiTerm-2%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[更新日志 2018-05-20 Mac安装powerline 权限问题 一、前言iTerm2是MAC下最好用的终端工具，并且还是免费的。iTerm2 是配置完毕开箱即用的 tmux，有标签变色、智能选中等特色功能。在日常开发中，我们难免会与终端命令打交道，比如使用Git，CocoaPods，Homebrew，Hexo等，下面开始介绍自定义终端样式吧！ 二、目录 下载安装iTerm 2 安装powerline 安装oh-my-zsh 安装字体库fonts 导入配色 主题设置 添加指令高亮效果zsh-syntax-highlighting 快捷键 问题解决 三、下载安装iTerm 2 GitHub 四、安装powerline12345//没有安装pip先安装pipsudo easy_install pip//之后安装powerline（这里可能会报错，可以参考问题解决）pip install powerline-status 五、安装oh-my-zsh1curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 六、安装字体库fonts123456//克隆字体库到本地git clone https://github.com/powerline/fonts.git//安装字体cd fonts./install.sh 安装成功之后输出：123➜ fonts git:(master) ./install.shCopying fonts...Powerline fonts installed to /Users/WENBO/Library/Fonts 七、导入配色 首先到GitHub下载solarized 1git clone https://github.com/altercation/solarized 解压zip文件，进入solarized/iterm2-colors-solarized文件，双击Solarized Dark.itermcolors和Solarized Light.itermcolors进行安装导入，如下图所示 进入系统偏好设置，profiles-&gt;Colors选择刚刚导入的配色方案即可八、主题设置 使用agnoster，下载安装： 123456//克隆主题到本地git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor//安装主题cd oh-my-zsh-agnoster-fcamblor./install 安装成功之后，编辑~/.zshrc文件，将ZSH_THEME改为agnoster 1234# Set name of the theme to load. Optionally, if you set this to &quot;random&quot;# it&apos;ll load a random theme each time that oh-my-zsh is loaded.# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME=&quot;agnoster&quot; 九、添加指令高亮效果zsh-syntax-highlighting 下载文件 12//克隆项目到本地git clone git://github.com/zsh-users/zsh-syntax-highlighting.git 编辑.zshrc文件，在最后添加如下内容 12source /Users/WENBO/zsh-syntax-highlighting/zsh-syntax-highlighting.zshplugins=(zsh-syntax-highlighting) 注意1/Users/WENBO是*.zshrc文件所在路径，这里替换成你自己的就好了 设置成功之后，效果如下： 十、快捷键自己也才安装，先记录下来吧。 说明 快捷键 新建标签 command + t 关闭标签 command + w 切换标签 command + 数字 command + 左右方向键 切换全屏 command + enter 查找 command +f 垂直分屏 command + d 水平分屏 command + shift + d 切换屏幕 command + option + 方向键 command + [ 或 command + ] 查看历史命令 command + ; 查看剪贴板历史 command + shift + h 清除当前行 ctrl + u 到行首 ctrl + a 到行尾 ctrl + e 前进后退 ctrl + f/b (相当于左右方向键) 上一条命令 ctrl + p 搜索命令历史 ctrl + r 删除当前光标的字符 ctrl + d 删除光标之前的字符 ctrl + h 删除光标之前的单词 ctrl + w 删除到文本末尾 ctrl + k 交换光标处文本 ctrl + t 清屏1 command + r 清屏2 ctrl + l 十一、问题解决 brew link python报错12sudo mkdir /usr/local/Frameworkssudo chown $(whoami):admin /usr/local/Frameworks 之后执行，链接成功1brew link python 安装powerline报错Permission denied，原因是没有安装python,，通过homebrew安装python 1brew install python 命令显示？号，如下图所示：解决办法：进入Preference-&gt;Profiles-&gt;Text，做如下配置即可： Mac安装powerline 权限问题，报错如下解决办法：1pip install powerline-status --user -U 十二、结语在掘金上发现了这款终端工具，自己平时也有用到终端工具，于是就尝试给自己的MAC装上这款软件，在安装过程中还是遇到一些问题，不过最后都解决了。如果你也爱好终端命令操作，可以尝试DIY你喜欢的终端样式哦。 参考文章 iTerm 2 &amp;&amp; Oh My Zsh【DIY教程——亲身体验过程】 Mac终端iTerm2配置]]></content>
      <categories>
        <category>Terminal</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
        <tag>MAC</tag>
        <tag>item2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cell自适应高度标签]]></title>
    <url>%2F2018%2F07%2F08%2FCell%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[一、本地数据自适应 在做项目意见反馈的时候，需要选择反馈类型，整个界面是UITableView，我现在喜欢用自动布局，用的Masonry布局框架，开始选择类型是放在本地的，用Masonry实现cell高度自适应还算相对简单的，下面是实现数据在本地高度自适应的核心代码，该方法在cell初始化方法中调用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172- (void)initSubviews &#123; /** &lt;&lt; init subviews &gt; */ CGFloat margin = 15.f; CGFloat spacing = 10.f; CGFloat maxWidth = ScreenWidth; __block CGFloat rowWidth = 0; __block BOOL isNeedChangeLine = YES; __block UIButton *lastButton = nil; NSInteger count = self.dataArray.count; [self.dataArray enumerateObjectsUsingBlock:^(CYBImageTitleModel * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.titleLabel.font = FONT(14.f); button.adjustsImageWhenHighlighted = NO; [button setTitleColor:[UIColor lightGrayColor] forState:UIControlStateNormal]; [button setTitleColor:Color_Orange forState:UIControlStateSelected]; [button setBackgroundImage:obj.image forState:UIControlStateNormal]; [button setBackgroundImage:obj.selectedImage forState:UIControlStateSelected]; [button setTitle:obj.title forState:UIControlStateNormal]; button.tag = kBTN_TAG + idx; button.selected = obj.isSelected; if (obj.isSelected) &#123; tempBtn = button; &#125; [button wb_addTarget:self action:@selector(buttonClicked:)]; [self.contentView addSubview:button]; CGFloat titleWidth = [obj.title boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, 28) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName : FONT(14.f)&#125; context:nil].size.width + 2 * 8; rowWidth += titleWidth + spacing; /** &lt; 是否需要换行 &gt; */ if (rowWidth &gt; maxWidth - 2 * margin) &#123; isNeedChangeLine = YES; /** &lt; 判断是否超过最大值 &gt; */ if (titleWidth + 2 * margin &gt; maxWidth) &#123; titleWidth = maxWidth - 2 * margin; &#125; /** &lt; 换行后重新设置当前行的总宽度 &gt; */ rowWidth = titleWidth + spacing; &#125; [button mas_makeConstraints:^(MASConstraintMaker *make) &#123; /** &lt; 换行 &gt; */ if (isNeedChangeLine) &#123; if (!lastButton) &#123; make.top.equalTo(self.contentView.mas_top).offset(margin); &#125;else &#123; make.top.equalTo(lastButton.mas_bottom).offset(spacing); &#125; make.left.equalTo(self.contentView.mas_left).offset(margin); isNeedChangeLine = NO; &#125;else &#123; make.left.equalTo(lastButton.mas_right).offset(spacing); make.top.equalTo(lastButton.mas_top); &#125; make.height.mas_equalTo(@(28)); make.width.mas_equalTo(@(titleWidth)); /** &lt; 最后一个 &gt; */ if (idx == count - 1) &#123; make.bottom.equalTo(self.contentView.mas_bottom).offset(-margin); &#125; &#125;]; lastButton = button; &#125;];&#125; 二、网络请求数据高度自适应 后来改需求了，需要从网络请求意见反馈类型，好吧，上面的方法已经有实现高度自适应关键代码了，只要稍作修改就可实现了。但是实现过程并不是想象中那么简单，中间也经理了很多波折。因为时间还是很充裕的，我就考虑到将标签空间封装成一个视图，等要使用的时候自己添加到cell上，并设置上下左右约束，封装完成之后并没有达到我想要的效果，我发现cell根本就撑不起来，我检查了一遍约束，上下左右约束没有遗漏呀，封装的视图WBAutoTagListView核心代码如下，约束实在layoutSubviews设置的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma mark &lt; Layout &gt;- (void)layoutSubviews &#123; [super layoutSubviews]; CGFloat maxWidth = self.bounds.size.width - _secionInset.left - _secionInset.right; __block CGFloat rowWidth = 0; __block BOOL isNeedChangeLine = YES; __block WBTagListItem *lastItem = nil; NSInteger count = self.itemArray.count; [self.itemArray enumerateObjectsUsingBlock:^(WBTagListItem * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; CGFloat titleWidth = obj.titleWidth; rowWidth += titleWidth + _minimumInteritemSpacing; /** &lt; 是否需要换行 &gt; */ if (rowWidth &gt; maxWidth - 2 * _minimumInteritemSpacing) &#123; isNeedChangeLine = YES; /** &lt; 判断是否超过最大值 &gt; */ if (titleWidth + 2 * _minimumInteritemSpacing &gt; maxWidth) &#123; titleWidth = maxWidth - 2 * _minimumInteritemSpacing; &#125; /** &lt; 换行后重新设置当前行的总宽度 &gt; */ rowWidth = titleWidth + _minimumInteritemSpacing; &#125; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; /** &lt; 换行 &gt; */ if (isNeedChangeLine) &#123; if (!lastItem) &#123; make.top.equalTo(self.mas_top).offset(_secionInset.top); &#125;else &#123; make.top.equalTo(lastItem.mas_bottom).offset(_minimumLineSpacing); &#125; make.left.equalTo(self.mas_left).offset(_secionInset.left); isNeedChangeLine = NO; &#125;else &#123; make.left.equalTo(lastItem.mas_right).offset(_minimumInteritemSpacing); make.top.equalTo(lastItem.mas_top); &#125; make.height.mas_equalTo(@(_itemHeight)); make.width.mas_equalTo(@(titleWidth)); /** &lt; 最后一个 &gt; */ if (idx == count - 1) &#123; make.bottom.mas_offset(-_secionInset.bottom).priorityMedium(); &#125; &#125;]; lastItem = obj; &#125;]; NSLog(@&quot;%f&quot;,[self systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height);&#125; 经测试，将该视图添加到控制器的视图上是可以自适应高度的，但是添加的cell上，就无法撑cell高度，尝试了许多写法，还是未能实现，控制台提示了无法算出cell的高度，就给了一个默认高度，顿时都无语了，有知道的大神能告诉我为什么有内容却无法撑起cell高度吗？ 既然封装的视图无法实现cell高度自适应，我就尝试另外的思路方法，既然是cell自适应，那就索性封装一个标签cell吧WBTagListViewCell，为了可复用性，也为WBTagListViewCell添加了一些配置属性，如下： 123456789101112131415161718192021222324252627282930313233343536373839/** &lt; 数据源 &gt; */@property (nonatomic, strong) NSArray &lt;WBTagListModel *&gt;*items;/** &lt; 内边距 默认： UIEdgeInsetsMake(15, 15, 15, 15) &gt; */@property (nonatomic, assign) UIEdgeInsets secionInset;/** &lt; 行间距 默认：15 &gt; */@property (nonatomic, assign) CGFloat minimumLineSpacing;/** &lt; item之间距离 默认：10 &gt; */@property (nonatomic, assign) CGFloat minimumInteritemSpacing;/** &lt; 是否允许点击 默认：YES &gt; */@property (nonatomic, assign) BOOL allowSelection;/** &lt; 是否允许多选 默认：NO &gt; */@property (nonatomic, assign) BOOL allowMultipleSelection;/** &lt; 标签高度 默认：28.f &gt; */@property (nonatomic, assign) CGFloat itemHeight;/** &lt; 标签左右间距 默认：10.f &gt; */@property (nonatomic, assign) CGFloat leftRightMargin;/** &lt; 背景图片 &gt; */@property (nonatomic, copy) NSString *bgImageName;/** &lt; 选中背景图片 &gt; */@property (nonatomic, copy) NSString *selectedBgImageName;/** &lt; 标签颜色 默认：浅灰色 &gt; */@property (nonatomic, strong) UIColor *titleColor;/** &lt; 按钮选中颜色 &gt; */@property (nonatomic, strong) UIColor *titleSelectedColor;/** &lt; 标题大小 默认：14pt &gt; */@property (nonatomic, strong) UIFont *font;/** &lt; 边框宽度 默认：0 &gt; */@property (nonatomic, assign) CGFloat borderWidth;/** &lt; 边框颜色 bodoerWidth &gt; 0 设置有效 &gt; */@property (nonatomic, strong) UIColor *borderColor;/** &lt; 选中边框颜色 bodoerWidth &gt; 0 设置有效 &gt; */@property (nonatomic, strong) UIColor *selectedBorderColor;/** &lt; 圆角大小 默认：0 &gt; */@property (nonatomic, assign) CGFloat cornerRadius;/** &lt; 选中的item &gt; */@property (nonatomic, strong) NSMutableArray *selectedItems;@property (nonatomic, weak) id &lt;WBTagListViewCellDelegate&gt; delegate; 关键实现步骤是重写了cell的updateConstraints，在有数据源的时候调用setNeedsUpdateConstraints，关键代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172- (void)createTagWithData:(NSArray &lt;WBTagListModel *&gt;*)itemsArray &#123; for (UIView *view in self.itemArray) &#123; [view removeFromSuperview]; &#125; [self.itemArray removeAllObjects]; for (NSInteger index = 0; index &lt; itemsArray.count; index ++) &#123; WBTagListItem *item = [WBTagListItem new]; item.title = itemsArray[index].title; item.isSelected = itemsArray[index].isSelected; item.itemTag = index; item.delegate = self; [self.contentView addSubview:item]; [self.itemArray addObject:item]; /** &lt; 默认选中第一个 &gt; */ if (index == 0 &amp;&amp; itemsArray[index].isSelected) &#123; _tempItem = item; [self.selectedItems removeAllObjects]; [self.selectedItems addObject:_tempItem]; &#125; &#125; [self setNeedsUpdateConstraints];&#125;- (void)updateConstraints &#123; [super updateConstraints]; CGFloat maxWidth = self.contentView.bounds.size.width - _secionInset.left - _secionInset.right; __block CGFloat rowWidth = 0; __block BOOL isNeedChangeLine = YES; __block WBTagListItem *lastItem = nil; NSInteger count = self.itemArray.count; [self.itemArray enumerateObjectsUsingBlock:^(WBTagListItem * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; CGFloat titleWidth = obj.titleWidth; rowWidth += titleWidth + _minimumInteritemSpacing; /** &lt; 是否需要换行 &gt; */ if (rowWidth &gt; maxWidth - 2 * _minimumInteritemSpacing) &#123; isNeedChangeLine = YES; /** &lt; 判断是否超过最大值 &gt; */ if (titleWidth + 2 * _minimumInteritemSpacing &gt; maxWidth) &#123; titleWidth = maxWidth - 2 * _minimumInteritemSpacing; &#125; /** &lt; 换行后重新设置当前行的总宽度 &gt; */ rowWidth = titleWidth + _minimumInteritemSpacing; &#125; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; /** &lt; 换行 &gt; */ if (isNeedChangeLine) &#123; if (!lastItem) &#123; make.top.equalTo(self.contentView.mas_top).offset(_secionInset.top); &#125;else &#123; make.top.equalTo(lastItem.mas_bottom).offset(_minimumLineSpacing); &#125; make.left.equalTo(self.contentView.mas_left).offset(_secionInset.left); isNeedChangeLine = NO; &#125;else &#123; make.left.equalTo(lastItem.mas_right).offset(_minimumInteritemSpacing); make.top.equalTo(lastItem.mas_top); &#125; make.height.mas_equalTo(@(_itemHeight)); make.width.mas_equalTo(@(titleWidth)); /** &lt; 最后一个 &gt; */ if (idx == count - 1) &#123; make.bottom.equalTo(self.contentView.mas_bottom).offset(-_secionInset.bottom).priorityMedium(); &#125; &#125;]; lastItem = obj; &#125;];&#125; 最后运行效果也贴一张图吧 封装cell在实现过程中，也遇到一些问题，最开始把约束写到layoutSubviews还是无法自适应高度，再就是要考虑到cell复用的问题。不管怎样最后还是实现了自己想要的效果，由于技术有限，可能我有写的不对不好的地方，还请斧正。最后也贴出自动布局和frame布局标签demo，如果觉得对你有帮助，请Star鼓励下吧。三、GitHub DemoAuto：WBAutoTagListViewDemoFrame：WB_TagsViewDemo 参考 Apple官方文档]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[item2自动连接SSH]]></title>
    <url>%2F2018%2F07%2F08%2Fitem2%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5SSH%2F</url>
    <content type="text"><![CDATA[目录 1、编辑命令脚本2、配置item2 1、编辑命令脚本 2.1.1 打开item2终端，创建脚本文件CentOSAutoLoginSSH（名字可以自定义）文件，保存在一个你指定的文件夹下： 12345//切换文件夹cd [你要保存的文件夹下]//创建文件touch CentOSAutoLoginSSH 2.1.2 编辑CentOSAutoLoginSSH 1vim CentOSAutoLoginSSH 2.1.3 配置CentOSAutoLoginSSH123456789101112131415161718#!/usr/bin/expect -f #搬瓦工控制面板中的SSH Port set port 2121 #默认用户名root set user root #主机地址 set host 172.16.10.71 #密码 set password mima123456 set timeout -1 spawn ssh -p$port $user@$host expect &quot;*assword:*&quot; send &quot;$password\r&quot; interact expect eof :wq 编辑完成之后:wq保存配置信息。 2、配置item2 2.2.1 item2-&gt;Preference-&gt;Profile添加配置文件，操作如下图所示： 2.2.2 测试免密自动登录，选择顶部菜单Profile中的CentOSAutoLoginSSH，这时可能会报错，因为CentOSAutoLoginSSH没有执行权限，需要执行以下命令：1chmod u+x /Users/user/.ssh/CentOSAutoLoginSSH 然后测试，就实现了免密自动登录了。 2.2.3 然后我们就可以查看shadowsocks文件下的配置文件了1cat /etc/shadowsocks/config.json 参考文章 使用iTerm2快捷连接SSH Mac Item2 SSH免密登录Linux 服务器的两种方式]]></content>
      <categories>
        <category>MAC</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
        <tag>item2</tag>
        <tag>SSH</tag>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode无线真机调试]]></title>
    <url>%2F2018%2F07%2F08%2FXcode%E6%97%A0%E7%BA%BF%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一、硬性条件 硬件环境MAC、Xcode9 系统Mac OSX 10.12.5、iOS11二、具体操作步骤 将手机用数据线连接到MAC，Xcode-&gt;Devices And Simulators-&gt;Devices中勾选connect via network 点击手机图标，鼠标右键，配置局域网Connect via IP Address 配置完成之后手机图标会有一个地球标志，带表已经连接成功 最后运行项目，就可以无线调试啦]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>LLDB</tag>
        <tag>Xcode</tag>
        <tag>iPhone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS定位处理约束冲突]]></title>
    <url>%2F2018%2F07%2F08%2FiOS%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86%E7%BA%A6%E6%9D%9F%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[一、添加UIViewAlertForUnsatisfiableConstraints断点 添加Symbolic Breakpoints 编辑断点symbol填入 1UIViewAlertForUnsatisfiableConstraints 添加控制台打印action 1po [[UIWindow keyWindow] _autolayoutTrace] 二、定位约束警告冲突 添加好断点之后，当界面有约束冲突，就会触发断点，控制打印如下： 1234567891011121314151617[LayoutConstraints] Unable to simultaneously satisfy constraints. Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. ( &lt;MASLayoutConstraint:0x604000ab04a0 UIButton:0x7faf99f04010.width == 40&gt;, &lt;MASLayoutConstraint:0x604000ab66e0 UIButton:0x7faf99f04010.left == CYBButtonView:0x7faf99f83360.left + 10&gt;, &lt;MASLayoutConstraint:0x604000abaa00 UILabel:0x7faf99f5f8e0.left == UIButton:0x7faf99f04010.right&gt;, &lt;MASLayoutConstraint:0x604000abd580 UILabel:0x7faf99f5f8e0.left == CYBButtonView:0x7faf99f83360.left + 15&gt;,)Will attempt to recover by breaking constraint &lt;MASLayoutConstraint:0x604000ab04a0 UIButton:0x7faf99f04010.width == 40&gt;Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful. 根据提示，找到约束有问题的控件地址0x7faf99f04010，然后全局搜索，就能找到具体是哪个控件 如果控制台打印不够直观看出是哪个控件约束有问题，我们可以通过 LLDB命令工具chisel定位寻找。 三、解决冲突通常解决冲突的方法有： 删除多余约束 修改约束优先级 参考1、How to trap on UIViewAlertForUnsatisfiableConstraints?]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Chisel</tag>
        <tag>Objective-C</tag>
        <tag>Xcode</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chisel-LLDB调试助手]]></title>
    <url>%2F2018%2F07%2F08%2FChisel-LLDB%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[Chisel is a collection of LLDB commands to assist debugging iOS apps. 目录 GitHub地址 安装 常用常用Commands 推荐博客 一、GitHub地址Chisel 二、安装 未安装Homrebrew，先安装Homrebrew参考MAC上Homebrew常用命令 安装Chisel 1brew install chisel 如果没有创建.lldbinit文件，则在终端创建文件 12touch .lldbinit //open .lldbinit 编辑.lldbinit文件，并添加以下内容command script import /usr/local/opt/chisel/libexec/fblldb.py 123456vim .lldbinit//添加以下内容# ~/.lldbinit...command script import /path/to/fblldb.py 最后wq保存，重启Xcode，就可以使用Chisel了。 三、常用Commands 命令 命令描述 iOS OS X pviews Print the recursive view description for the key window. YES YES pvc Print the recursive view controller description for the key window. YES NO visualize Open a UIImage, CGImageRef, UIView, CALayer, NSData (of an image), UIColor, CIColor, or CGColorRef in Preview.app on your Mac. YES NO fv Find a view in the hierarchy whose class name matches the provided regex. YES NO fvc Find a view controller in the hierarchy whose class name matches the provided regex. YES NO show/hide Show or hide the given view or layer. You don’t even have to continue the process to see the changes! YES YES mask/unmask Overlay a view or layer with a transparent rectangle to visualize where it is. YES NO border/unborder Add a border to a view or layer to visualize where it is. YES YES caflush Flush the render server (equivalent to a “repaint” if no animations are in-flight). YES YES bmessage Set a symbolic breakpoint on the method of a class or the method of an instance without worrying which class in the hierarchy actually implements the method. YES YES wivar Set a watchpoint on an instance variable of an object. YES YES presponder Print the responder chain starting from the given object. YES YES … … … … 就介绍这么多了，现在自己用到的也并不算太多，做下记录，方便自己以后查阅，有兴趣的朋友可以自行了解其用法吧。 推荐博客1、LLdb篇2教你使用faceBook的chisel来提高调试效率2、Chisel-LLDB命令插件，让调试更Easy]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>LLDB</tag>
        <tag>Terminal</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS优秀三方开源库整理，了解一下]]></title>
    <url>%2F2018%2F07%2F08%2FiOS%E4%BC%98%E7%A7%80%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E5%BA%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、前言 在自己工作之余，收集整理了一些优秀的三方开源框架，自己整理的这些三方开源库涵盖了iOS开发面很多方面的知识。非常感谢这些开源库的作者们，正是因为这些库，提高了我们的开发效率，同样也是我们学习进步的源泉。现将这个整理工程文件分享出来，希望能给需要的朋友一些帮助，同时也自己也做下收集记录。 Github整理地址 Objective-C三方库整理 Swift三方库整理 二、Objective-C三方开源库表格侧滑菜单 MGSwipeTableCell SWTableViewCell ZJSwipeTableView 表格高度缓存库 FDTemplateLayoutCellTemplate auto layout cell for automatically UITableViewCell height calculating. HYBMasonryAutoCellHeight 表格刷新控件 MJRefresh KafkaRefresh 弹出菜单（类似微信弹出菜单） FTPopOverMenu kxmenu PopMenuTableView 导航栏相关 FDFullscreenPopGesture全屏返回手势 KMNavigationBarTransition RTRootNavigationController WRNavigationBar 动画 lottie-ios pop LSAnimator 分段（分类）控件 HMSegmentedControl比较经典的分段控件。 JXCategoryViewA powerful and easy to use category view (segmentedcontrol, segmentview, pagingview, pagerview, pagecontrol) (腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等所有主流APP分类切换滚动视图)。 富文本编辑 ZSSRichTextEditor基于UIWebView实现富文本编辑功能，可能由于作者很少维护，使用有很多的bug 弹幕 HJDanmakuDemo 滚动视图 SwipeView 滚动视图嵌套 HJTabViewController LTScrollView 红点提示 JSBadgeView WZLBadge 键盘 IQKeyboardManagerCodeless drop-in universal library allows to prevent issues of keyboard sliding up and cover UITextField/UITextView. Neither need to write any code nor any setup required and much more.一款强大键盘管理库。 MMNumberKeyboard数字键盘。 TPKeyboardAvoiding 界面布局 FlexLibFlexLib is a framework for creating native iOS applications using xml file, similar to Android and .NET development way.类似于安卓xml布局。 MasonryHarness the power of AutoLayout NSLayoutConstraints with a simplified, chainable and expressive syntax. Supports iOS and OSX Auto Layout.对苹果原生AutoLayout的封装，链式语法，纯代码开发必备布局库。 SDAutoLayoutOne line of code to implement automatic layout. 一行代码搞定自动布局！支持Cell和Tableview高度自适应，Label和ScrollView内容自适应，致力于做最简单易用的AutoLayout库。The most easy way for autoLayout. Based on runtime. WHC_AutoLayoutKit MyLinearLayoutMyLayout是一套iOS界面视图布局框架。MyLayout的内核是基于对UIView的layoutSubviews方法的重载以及对子视图的bounds和center属性的设置而实现的。MyLayout功能强大而且简单易用，它集成了:iOS Autolayout和SizeClass、android的5大布局体系、HTML/CSS的浮动定位技术以及flex-box和bootstrap框架等市面上主流的平台的界面布局功能，同时提供了一套非常简单和完备的多屏幕尺寸适配的解决方案。之前自己布局一直用Frame、Masonry，Xib布局，最近也在学习这款强大的布局框架。 进度指示器 DACircularProgress SDProgressView 开发模式 KVOController 控制器切换 DWQListOfDifferentOrderStatus HYPageView SGPagingView WMPageController ZJScrollPageView 数据存储 fmdb BGFMDB JKDBModel JRDB LKDBHelper-SQLite-ORM 数据转模型 MJExtension YYModel Mantle jsonmodel GDataXML-HTML 搜索 PYSearch 提示框架 MBProgressHUD SVProgressHUD JGProgressHUD KSToastView MMPopupView SCLAlertView Toast 图表绘制 AAChartKit JHChart ZFChart DVPieChart DVLineChart 图片缓存框架 SDWebImage FLAnimatedImage iOS-WebP YYWebImage 图片浏览 MWPhotoBrowser PYPhotoBrowser SDPhotoBrowser STPhotoBrowser KSPhotoBrowser 图片轮播 SDCycleScrollView HYBLoopScrollView TXScrollLabelView 图片拾取 TZImagePickerController一个支持多选、选原图和视频的图片选择器，同时有预览、裁剪功能，支持iOS6+。 CTAssetsPickerController DNImagePicker HXWeiboPhotoPicker 3D效果图 HelloPanoramaGL 网络请求 AFNetworkingA delightful networking framework for iOS, macOS, watchOS, and tvOS. YTKNetwork PPNetworkHelper HYBNetworking SJNetwork 网络状态监测 Reachability 文件下载 TWRDownloadManager ZFDownload 旋转木马 iCarousel NewPagedFlowView 音视频 ijkplayer ZFPlayer WMPlayer TBPlayer TTAVPlayer 占位图 DZNEmptyDataSetA drop-in UITableView/UICollectionView superclass category for showing empty datasets whenever the view has no content to display.集合视图表格视图无数据占位图设置框架，使用只需设置代理、实现代理方法，就能完成占位图设置，非常值得推荐 LYEmptyView C语言扩展库 libextobjc Socket编程 CocoaAsyncSocket SocketRocket socket.io MQTTKit 内存泄露检测工具 MLeaksFinder腾讯开源内存泄漏检测框架，非常好用，值得推荐。 FBRetainCycleDetectoriOS library to help detecting retain cycles in runtime. YYKit YYKit LOG工具 CocoaLumberjackA fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS. OC与JS交互 WebViewJavascriptBridge 输入框占位符 UITextView-Placeholder RPFloatingPlaceholders SZTextView 分类 JKCategories 图像处理 GPUImage iOS开发知识集合 iOS-TipsiOS知识小集，iOS知识小集的初衷是希望用300字左右（外加代码和效果展示）来说明一个小知识点，这样读者可以在上下班路上，花个2分钟就能了解一个iOS开发的小知识。 面试题集锦 iOSInterviewQuestionsiOS面试题集锦（附答案），分为两篇《招聘一个靠谱的 iOS》—参考答案（上） 、《招聘一个靠谱的 iOS》—参考答案（下），面试前值得学习与了解。 iOS-InterviewQuestion-collectioniOS 开发者在面试过程中，常见的一些面试题，建议尽量弄懂了原理，并且多实践。 三方开源库分析 analyze主要记录了Draveness大神阅读开源框架源代码的心得，主要框架包括SDWebImage、MBProgressHUD、Masonry、AFNetworking、KVOController等，有兴趣的朋友可以到GitHub阅读。 三、Swift三方开源库动画 NVActivityIndicatorView一组极棒的加载动画集合。 网络请求 Alamofire Swift优雅的HTTP网络请求库。 占位图 SkeletonView 二维码扫描 EFQRCode 布局框架 SnapKit 图表绘制 Charts四、结语 上面这些三方开源库按照自己的理解分类整理了一遍，其中OC语言库居多，自己现在也是基于OC开发，Swift收集的相对较少，这些库也是自己现在所了解到的，当然还有很多优秀的三方库自己也未发现和接触，我以后会不断在这篇博客中更新优秀的三方开源库。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GitHub</tag>
        <tag>Objective-C</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitPages+Hexo搭建个人博客]]></title>
    <url>%2F2018%2F07%2F07%2FGitPages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[如果你想从零开始搭建一个属于自己的静态博客网站，可以参考下面三篇博文，这三篇博文是记录我从零开始搭建自己静态博客的全过程，希望能给需要的朋友一些参考： GitPages+Hexo搭建个人博客 Hexo相关配置和使用 Hexo-NexT配置超炫网页效果 最终成果： blogwenbo.com 一、GitHub创建项目 1.1 使用GitPages搭建自己静态博客前提要注册申请GitHub账号。GitHub相关配置可参考这篇文章：MAC上Git安装与GitHub基本使用。 1.2 GitHub上新创建一个wenmobo.github.io仓库，wenmobo是我的账号名，这里替换成你自己的就可以了。项目格式名称为[用户名].github.io，如下：1username.github.io 创建成功之后如下： 1.3 在桌面新建一个文件夹MyBlog，cd到该文件夹，将项目克隆到本地：1git clone git@github.com:wenmobo/wenmobo.github.io.git 二、安装Node.js 2.1 Node.js支持用HomeBrew安装，首先要安装Homebrew，Homebrew安装可查看这篇文章：MAC上Homebrew常用命令整理 2.2 Homebrew安装好之后，用Homebrew安装Node.js，终端输入：1brew node 三、安装hexo 3.1 安装hexo，终端输入： 1npm install -g hexo-cli 3.2 在本地仓库MyBlog新建文件夹Blog，然后在终端cd [Blog文件夹路径]，执行以下命令初始化博客： 123456hexo init//或者hexo init &lt;folder&gt;cd &lt;folder&gt;npm instal 成功之后，目录文件如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 3.3 查看本地效果，终端输入：1hexo s 终端输出：123WMBdeMacBook-Pro:Hexo WENBO$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 将http://localhost:4000/.拷贝到Chome浏览器，查看效果，如下图所示： 四、总结 GitHubPages+Hexo搭建静态博客的准备工作到这里都完成了，下面一篇文章：Hexo相关配置和使用会介绍Hexo相关配置。 五、参考文章1、GithubPages教程 在GithubPages上搭建个人主页2、在Github上使用Hexo搭建个人博客3、如何使用hexo搭建个人博客（Mac OS系统，windows仅作参考）4、Hexo博客主题推荐]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>GitPages</tag>
      </tags>
  </entry>
</search>
